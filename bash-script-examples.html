<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>9 Bash Script Examples to Get You Started on Linux | PulseDash</title><meta name=generator content="Hugo 0.98.0"><meta name=description content="Quick LinksRemember, Make Your Scripts Executable  What's That Strange First Line?  Printing Text  Creating and Using Variables  Handling User Input  Accepting Parameters  Reading Data From Files  Using Conditional Tests  The Power of for Loops  Functions  Don't Fear the Learning Curve   If you're starting out with Bash scripting on Linux, getting a solid grasp of the basics will stand you in good stead."><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/normalize.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel=stylesheet type=text/css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/cayman.css><link rel=apple-touch-icon sizes=180x180 href=./apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=./favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=./favicon-16x16.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css integrity=sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js integrity=sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><section class=page-header><h1 class=project-name>PulseDash</h1><h2 class=project-tagline></h2><nav><a href=./index.html class=btn>Blog</a>
<a href=./sitemap.xml class=btn>Sitemap</a>
<a href=./index.xml class=btn>RSS</a></nav></section><section class=main-content><h1>9 Bash Script Examples to Get You Started on Linux</h1><div><strong>Publish date: </strong>2024-09-14</div><h3>Quick Links</h3><ul class=table-content-level-1><li><a href=#>Remember, Make Your Scripts Executable</a></li></ul><ul class=table-content-level-1><li><a href=#>What's That Strange First Line?</a></li></ul><ul class=table-content-level-1><li><a href=#>Printing Text</a></li></ul><ul class=table-content-level-1><li><a href=#>Creating and Using Variables</a></li></ul><ul class=table-content-level-1><li><a href=#>Handling User Input</a></li></ul><ul class=table-content-level-1><li><a href=#>Accepting Parameters</a></li></ul><ul class=table-content-level-1><li><a href=#>Reading Data From Files</a></li></ul><ul class=table-content-level-1><li><a href=#>Using Conditional Tests</a></li></ul><ul class=table-content-level-1><li><a href=#>The Power of for Loops</a></li></ul><ul class=table-content-level-1><li><a href=#>Functions</a></li></ul><ul class=table-content-level-1><li><a href=#>Don't Fear the Learning Curve</a></li></ul><p>If you're starting out with <a href=#>Bash scripting</a> on Linux, getting a solid grasp of the basics will stand you in good stead. They're the foundation of deeper knowledge and higher scripting skills.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=remember-make-your-scripts-executable>Remember, Make Your Scripts Executable</h2><p>For the shell to execute a script, the script must have the executable <a href=#>file</a> permission set. Without this, your script is just a text file. With it, it's still a text file, but the shell knows it contains instructions and will try to execute them when the script is launched.</p><p>The whole point of writing scripts is that they run, so the first basic step is to know how to let Linux know your script should be considered executable.</p><p><a href=#>The</a></p><pre><code class=hljs>chmod</code> </pre><p>command lets us set file permissions. The execute permission can be set with the +x flag.</p><pre>chmod +x script1.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/4-9.png><p>You'll need to do this to each of your scripts. Replace "script1.sh" with the name of your script.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=what-s-that-strange-first-line>1. What's That Strange First Line?</h2><p>The first line of a script tells the shell which interpreter should be called to run that script. The first line must start with a shebang, "#!", also known as a hashbang. The "#!" tells the shell that this line contains the path and name of the interpreter that the script was written for.</p><p>This is important because if you've written a script to run in Bash, you don't want it to be interpreted by a different shell. There are likely to be incompatibilities. Bash---like most shells---has its own quirks of syntax and functionality that other shells won't have, or will have implemented differently.</p><p>When you run a script, the current shell opens the script and determines which shell or interpreter should be used to execute that script. It then launches that shell and passes the script to it.</p><pre>#!/bin/bash  <p>echo Running in $SHELL</p></pre><p>The first line of this script can be read as "Use the interpreter located at /bin/bash to run this script."</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The only line in the script writes the value held in the <code>$SHELL</code> environmental variable to the terminal screen. This confirms that Bash was used to execute the script.</p><pre>./script1.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/1-10.png><p>As a bit of a parlor trick, we can demonstrate that the script is passed to any interpreter we select.</p><pre>#!/bin/cat  <p>All the lines of text are passed to the cat command</p>  <p>and are printed in the terminal window. That includes</p>  <p>the shebang line.</p></pre><pre>script2.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/2-9.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>This script is launched by the current shell and passed to <a href=#>the <code>cat</code> command</a>. The <code>cat</code> command "runs" the script.</p><p>Writing your shebangs like this makes an assumption that you know where the shell or other interpreter is located on the target machine. And 99% of the time, that's fine. But some people like to hedge their bets and write their shebangs like this:</p><pre>#!/usr/bin/env bash  <p>echo Running in $SHELL</p></pre><pre>script3.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/3-9.png><p>When the script is launched the shell&nbsp;searches&nbsp;for the location of the named shell. If the shell happens to be in a non-standard location, this type of approach can avoid "bad interpreter" errors.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h3 id=don-t-listen-he-s-lying>Don't Listen, He's Lying!</h3><p>In Linux, there's always more than one way to skin a cat or prove an author wrong. To be completely factual, there is a way to run scripts without a shebang, and without making them executable.</p><p>If you launch the shell that you want to execute the script and pass the script as a <a href=#>command line</a> parameter, the shell will launch and run the script--- whether it is executable or not. Because you choose the shell on the command line, there's no need for a shebang.</p><p>This is the entire script:</p><pre>echo "I've been executed by" $SHELL</pre><p>We'll use <code>ls</code> to see that the script really isn't executable and launch Bash with the name of the script:</p><pre>ls</pre><pre>bash script4.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/5-9.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>There's also a way to have a script run by the&nbsp;current&nbsp;shell, not a shell launched specifically to execute the script. If you use the <code>source</code> command, which can be abbreviated to a single period "<code>.</code>", your script is executed by your current shell.</p><p>So, to run a script without a shebang, without the executable file permission, and without launching another shell, you can use either of these <a href=#>commands</a>:</p><pre>source script4.sh</pre><pre>. script4.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/6-9.png><p>Although this is possible, it isn't recommended as a general solution. There are drawbacks.</p><p>If a script doesn't contain a shebang, you can't tell which shell it was written for. Are you going to remember in a year's time? And without the executable permission being set on the script, <a href=#>the <code>ls</code> command</a> won't identify it as an executable file, nor will it use color to distinguish the script from plain text files.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p><span class=related-single>Related: <a href=#>Command Lines: Why Do People Still Bother With Them?</a></span></p><h2 id=printing-text>2. Printing Text</h2><p>Writing text to the terminal is a common requirement. A bit of visual feedback goes a long way.</p><p>For simple messages, the&nbsp;<a href=#><code>echo</code> command will suffice</a>.&nbsp;It allows some formatting of the text and lets you work with variables too.</p><pre>#!/bin/bash  <p>echo This is a simple string.</p>  <p>echo "This is a string containing 'single quotes' so it's wrapped in double quotes."</p>  <p>echo "This prints the user name:" $USER</p>  <p>echo -e "The -e option lets us use\nformatting directives\nto split the string."</p></pre><pre>./script5.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/7-9.png><p><a href=#>The <code>printf</code> command</a> gives us more&nbsp;flexibility and better formatting capabilities&nbsp;including number conversion.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>This script prints the same number using three different numerical bases. The hexadecimal version is also formatted to print in uppercase, with leading zeroes and a width of three digits.</p><pre>#!/bin/bash  <p>printf "Decimal: %d, Octal: %o, Hexadecimal: %03X\n" 32 32 32</p></pre><pre>./script6.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/8-8.png><p>Note that unlike with <code>echo</code>, you must tell <code>printf</code> to start a new line with the "<code>\n</code>" token.</p><h2 id=creating-and-using-variables>3. Creating and Using Variables</h2><p>Variables allow you to store values inside your program and to manipulate and use them. You can&nbsp;<a href=#>create your own variables or use environment variables</a>&nbsp;for system values.</p><pre>#!/bin/bash  <p>millennium_text="Years since the millennium:"</p>  <p>current_time=$( date '+%H:%M:%S' )</p>  <p>todays_date=$( date '+%F' )</p>  <p>year=$( date '+%Y' )</p>   <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong>  <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <p>echo "Current time:" $current_time</p>  <p>echo "Today's date:" $todays_date</p>  <p>years_since_Y2K=$(( year - 2000 ))</p>  <p>echo $millennium_text $years_since_Y2K</p></pre><p>This script creates a string variable called <code>millennium_text</code>. It holds a line of text.</p><p>It then creates three numerical variables.</p><ul><li>The <code>current_time</code> variable is initialized to the time the script is executed.</li><li>The <code>todays_date</code> variable is set to the date on which the script is run.</li><li>The <code>year</code> variable holds the current year.</li></ul><p>To access the value stored in a variable, precede its name with a dollar sign "$."</p><pre>./script7.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/9-9.png><p>The script prints the time and date, then calculates how many years have passed since the millennium, and stores this in the <code>years_since_Y2K</code> variable.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>Finally, it prints the string contained in the <code>millennium_text</code> variable and the numerical value stored in the <code>years_since_Y2K</code>.</p><p><span class=related-single>Related: <a href=#>How to Work with Variables in Bash</a></span></p><h2 id=handling-user-input>4. Handling User Input</h2><p>To allow a user to enter a value that the script will use, you need to be able to capture the user's keyboard input. The Bash <code>read</code> command allows ut to do just that. Here's a simple example.</p><pre>#!/bin/bash  <p>echo "Enter a number and hit \"Enter\""</p>  <p>read user_number1;</p>  <p>echo "Enter another number and hit \"Enter\""</p>  <p>read user_number2;</p>  <p>printf "You entered: %d and %d\n" $user_number1 $user_number2</p>  <p>printf "Added together they make: %d\n" $(( user_number1 + user_number2))</p></pre><p>The script prompts for two numbers. They are read from the keyboard and stored in two variables, <code>user_number1</code> and <code>user_number2</code> .</p><p>The script prints the numbers to the terminal window, adds them together, and prints the total.</p><pre>./script8.sh</pre><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong> <img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/10-9.png><p>We can combine the prompts into the <code>read</code> commands using the <code>-p</code> (prompt) option.</p><pre>#!/bin/bash  <p>read -p "Enter a number and hit \"Enter\" " user_number1;</p>  <p>read -p "Enter another number and hit \"Enter\" " user_number2;</p>  <p>printf "You entered: %d and %d\n" $user_number1 $user_number2</p>  <p>printf "Added together they make: %d\n" $(( user_number1 + user_number2))</p></pre><p>This makes things neater and easier to read. Scripts that are easy to read are also easier to debug.</p><pre>./script9.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/11-10.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The script behaves slightly differently now. The user input is on the same line as the prompt.</p><p>To&nbsp;capture keyboard input without having it echoed to the terminal window, use the <code>-s</code> (silent) option.</p><pre>#!/bin/bash  <p>read -s -p "Enter your secret PIN and hit \"Enter\" " secret_PIN;</p>  <p>printf "\nShhh ... it is %d\n" $secret_PIN</p></pre><pre>./script10.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/12-8.png><p>The input value is captured and stored in a variable called <code>secret_PIN</code> , but it isn't echoed to the screen when the user types it. What you do with it after that is up to you.</p><h2 id=accepting-parameters>5. Accepting Parameters</h2><p>Sometimes it is more convenient to accept user input as command line parameters than to have a script sit waiting for input.&nbsp;Passing values to a script is easy. They can be referenced inside the script as if they were any other variable.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The first parameter becomes variable <code>$1</code>, the second parameter becomes variable <code>$2</code>, and so on. Variable <code>$0</code> always holds the name of the script, and variable <code>$#</code> holds the number of parameters that were provided on the command line. Variable <code>$@</code> is a string that contains all of the command line parameters.</p><pre>#!/bin/bash  <p>printf "This script is called: %s\n" $0</p>  <p>printf "You used %d command line parameters\n" $#</p>  <p># loop through the variables</p>  <p>for param in "$@"; do</p>  <p> echo "$param"</p>  <p>done</p>  <p>echo "Parameter 2 was:" $2</p></pre><p>This script uses <code>$0</code> and <code>$#</code> to print some information. then uses <code>?@</code> to loop through all of the command line parameters.&nbsp; It uses <code>$2</code> to show how to access a single, particular parameter value.</p><pre>./script11.sh</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/13-8.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>Wrapping several words in quotation marks """ combines them into a single parameter.</p><h2 id=reading-data-from-files>6. Reading Data From Files</h2><p>Knowing how to read data from a file is a great skill to have. We can do this in Bash&nbsp;<a href=#>with a while loop</a>.</p><pre>#!/bin/bash  <p>LineCount=0</p>  <p>while IFS='' read -r LinefromFile || [[ -n "${LinefromFile}" ]]; do</p>  <p> ((LineCount++))</p>  <p> echo "Reading line $LineCount: ${LinefromFile}"</p>  <p>done &lt; "$1"</p></pre><p>We're passing the name of the file we want the script to process as a command line parameter. It'll be the only parameter, so inside the script <code>$1</code> will hold the filename. We're redirecting that file into the <code>while</code> loop.</p><p><span class=related-single>Related: <a href=#>How to Process a File Line by Line in a Linux Bash Script</a></span></p><p>The <code>while</code> loop sets the internal field separator to an empty string, using the <code>IFS=''</code> assignment. This prevents the <code>read</code> command from splitting lines at whitespace. Only the carriage return at the end of a line is considered to be the true end of the line.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The <code>[[ -n "${LinefromFile}" ]]</code> clause caters for the possibility that the last line in the file doesn't end with a carriage return. Even if it doesn't, that last line will be handled correctly and treated as a regular POSIX-compliant line.</p><pre>./script12.sh twinkle.txt</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/14-8.png><h2 id=using-conditional-tests>7. Using Conditional Tests</h2><p>If you want your script to perform different actions for different conditions, you need to perform conditional tests. The&nbsp;<a href=#>double-bracket test syntax</a>&nbsp;delivers an---at first---overwhelming number of options.</p><pre>#!/bin/bash  <p>price=$1</p>  <p>if [[ price -ge 15 ]];</p>  <p>then</p>  <p> echo "Too expensive."</p>  <p>else</p>  <p> echo "Buy it!"</p>  <p>fi</p></pre><p>Bash provides a whole set of&nbsp;<a href=#>comparison operators</a>&nbsp;that let you determine things such as <a href=#>whether a file exists</a>, if you can read from it, if you can write to it, and whether a directory exists.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>It also has numerical tests for equals <code>-qe</code>, greater than <code>-gt</code>, less than or equal <code>-le</code>, and so on, although you can also use the familiar&nbsp; <code>==</code> , <code>>=</code> , <code>&lt;=</code>&nbsp; notation.</p><pre>./script13.sh 13</pre><pre>./script13.sh 14</pre><pre>./script13.sh 15</pre><pre>./script13.sh 16</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/15-8.png><h2 id=the-power-of-for-loops>8. The Power of for Loops</h2><p>Repeating actions over and over is best accomplished using loops. A <code>for</code> loop lets you&nbsp;<a href=#>run a loop a number of times</a>. This might be up to a particular number, or it might be until the loop has worked its way through a list of items.</p><pre>#!/bin/bash  <p>for (( i=0; i&lt;=$1; i++ ))</p>  <p>do</p>  <p> echo "C-style for loop:" $i</p>  <p>done</p>  <p>for i in {1..4}</p>  <p>do</p>  <p> echo "For loop with a range:" $i</p>  <p>done</p>  <p>for i in "zero" "one" "two" "three"</p>  <p>do</p>  <p> echo "For loop with a list of words:" $i</p> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong>  <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong>  <p>done</p>  <p>website="How To Geek"</p>  <p>for i in $website</p>  <p>do</p>  <p> echo "For loop with a collection of words:" $i</p>  <p>done</p></pre><p>All of these loops are <code>for</code> loops, but they're working with different types of loop statements and data.</p><pre>./script14.sh 3</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/16-9.png><p>The first loop is a classic C-style <code>for</code> loop. The loop counter <code>i</code> is initialized to zero, and incremented with each cycle of the loop. While the value of <code>i</code> is less than or equal to the value held in <code>$1</code>, the loop will continue to run.</p><p>The second loop works through the range of numbers from 1 to 4. The third loop works through a list of words. While there are more words to process, the loop keeps repeating.</p><p>The last loop works through the list of words in a string variable.</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=functions>9. Functions</h2><p>Functions allow you to encapsulate sections of code into named routines that can be called from anywhere within your script.</p><p>Suppose we wanted our script that reads lines from a file to do some sort of processing on each line. It would be convenient to have that code contained within a function.</p><pre>#!/bin/bash  <p>LineCount=0</p>  <p>function count_words() {</p>  <p> printf "%d words in line %d\n" $(echo $1 | wc -w) $2</p>  <p>}</p>  <p>while IFS='' read -r LinefromFile || [[ -n "${LinefromFile}" ]]; do</p>  <p> ((LineCount++))</p>  <p> count_words "$LinefromFile" $LineCount</p>  <p>done &lt; "$1"</p>  <p>count_words "This isn't in the loop" 99</p></pre><p>We've modified our file reading program by adding a function called <code>count_words</code>. It is defined before we need to use it.</p><p>The function definition starts with the word <code>function</code>. This is followed by a unique name for our function followed by parentheses "<code>()</code>." The body of the function is contained within curly brackets "{}."</p><strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><p>The function definition doesn't cause any code to be executed. Nothing in the function is run until the function is called.</p><p>The <code>count_words</code> function prints the number of words in a line of text, and the line number. These two parameters are passed into the function just like parameters are passed into a script. The first parameter becomes function variable <code>$1</code>, and the second parameter becomes function variable <code>$2</code>, and so on.</p><p>The <code>while</code> loop reads each line from the file and passes it to the <code>count_words</code> function, together with the line number. And just to show we can call the function from different places within the script, we call it once more outside of the <code>while</code> loop.</p><pre>./script15.sh twinkle.txt</pre><img style=margin:auto;display:block;text-align:center;max-width:100%;height:auto src=https://cdn.statically.io/img/static1.howtogeekimages.com/wordpress/wp-content/uploads/2022/05/17-5.png> <strong class="an-zone-tag-top ad-zone-advertising-tag"></strong> <strong class="an-zone-tag-bottom ad-zone-advertising-sub-tag"></strong><h2 id=don-t-fear-the-learning-curve>Don't Fear the Learning Curve</h2><p>Scripting is rewarding and useful, but tough to get into. Once you get some re-usable techniques under your belt you'll be able to write worthwhile scripts relatively easily. Then you can look into more advanced functionality.</p><p>Walk before you can run, and take time to enjoy the journey.</p><p><span class=related-single>Related: <a href=#>10 Basic Linux Commands for Beginners</a></span></p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7qbvWraagnZWge6S7zGhvaXBlboBwrsCsn2ark6e2scCMnq%2BapaChsrR7</p><footer class=site-footer><span class=site-footer-credits>Made with <a href=https://gohugo.io/>Hugo</a>. © 2022. All rights reserved.</span></footer></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>